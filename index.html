<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Product Visualizer (Optimized + Creative Layouts)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #ffffff;
        color: #000000;
        font-family: sans-serif;
        touch-action: none; /* Prevent default touch actions like scrolling/zooming on the canvas */
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      #loader {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.2em;
        color: #555;
        z-index: 101;
      }

      #controlsContainer {
        position: absolute;
        top: 10px;
        left: 10px;
        z-index: 100;
        display: flex;
        align-items: flex-start;
        touch-action: auto; /* Allow touch interaction within controls */
      }

      #controls {
        background-color: rgba(30, 30, 30, 0.75);
        color: #ffffff;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        max-height: 85vh;
        overflow-y: auto;
        max-width: 280px;
        box-sizing: border-box;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        transition: transform 0.3s ease-out, opacity 0.3s ease-out,
          max-width 0.3s ease-out, padding 0.3s ease-out;
        opacity: 1;
        transform: translateX(0);
      }

      #controls.collapsed {
        transform: translateX(-110%);
        opacity: 0;
        padding: 0;
        max-width: 0;
        border: none;
        overflow: hidden;
        pointer-events: none; /* Disable interaction when collapsed */
      }

      #toggleControlsButton {
        background-color: rgba(50, 50, 50, 0.8);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 5px;
        padding: 8px 10px;
        cursor: pointer;
        font-size: 16px;
        margin-left: 8px;
        z-index: 101;
        transition: background-color 0.2s ease;
      }
      #toggleControlsButton:hover {
        background-color: rgba(80, 80, 80, 0.9);
      }

      /* --- Responsive Design --- */
      @media (max-width: 768px) {
        #controlsContainer {
          top: 5px;
          left: 5px;
        }
        #controls {
          padding: 10px;
          font-size: 13px;
          max-width: calc(85% - 40px);
          max-height: 80vh;
          overflow-y: auto;
        }
        #controls.collapsed {
          transform: translateX(-110%);
        }
        #logoImage {
          height: 20px;
          margin-bottom: 10px;
        }
        #bgColorPicker {
          width: 30px;
          height: 18px;
        }
        #visitSiteButton {
          padding: 8px 12px;
          font-size: 0.85em;
        }
        #toggleControlsButton {
          padding: 8px 10px;
          font-size: 18px;
        }

        .layout-button {
          padding: 6px 8px;
          font-size: 0.8em;
          flex-grow: 1;
          min-width: 55px;
        }
        #layoutControls > div {
          gap: 8px;
        }
      }

      @media (max-width: 480px) {
        #controls {
          max-width: calc(90% - 30px);
          padding: 8px;
        }
        #logoImage {
          height: 18px;
          margin-bottom: 8px;
        }
        .layout-button {
          font-size: 0.75em;
          min-width: 50px;
        }
      }
      /* --- End Responsive Design --- */

      #logoImage {
        display: block;
        height: 40px; /* Adjust as needed */
        width: auto;
        margin-bottom: 20px;
      }
      #controls label {
        margin-bottom: 8px;
        display: block;
        font-weight: 600;
        font-size: 0.9em;
      }
      #controls h4 {
        margin: 0 0 10px 0;
        font-size: 1.1em;
        font-weight: 600;
      }
      #bgColorPicker {
        vertical-align: middle;
        cursor: pointer;
        border: 1px solid rgba(128, 128, 128, 0.5);
        width: 50px;
        height: 25px;
        margin-left: 5px;
        border-radius: 4px;
      }
      #selectedItemPanel {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid rgba(128, 128, 128, 0.5);
        display: none; /* Initially hidden */
        max-width: 200px; /* 데스크톱 최대 너비 */
      }
      #selectedItemImage {
        max-width: 100%;
        height: auto;
        margin-bottom: 10px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        max-height: 200px; /* 데스크톱 최대 높이 */
        object-fit: contain;
      }
      #visitSiteButton {
        display: block;
        width: 100%;
        padding: 10px 16px;
        margin-top: 10px;
        background-color: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        cursor: pointer;
        text-align: center;
        font-size: 0.9em;
        font-weight: 500;
        line-height: 1.3;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        position: relative;
        overflow: hidden;
      }

      #visitSiteButton::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        width: 100%;
        height: 100%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.2) 0%,
          rgba(255, 255, 255, 0) 70%
        );
        border-radius: inherit;
        opacity: 0;
        transition: transform 0.4s ease-out, opacity 0.4s ease-out;
      }

      #visitSiteButton:hover {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.6);
        transform: translateY(-2px);
        box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
      }

      #visitSiteButton:hover::before {
        transform: translate(-50%, -50%) scale(1.5);
        opacity: 1;
      }

      #visitSiteButton:active {
        transform: translateY(0px) scale(0.97);
        background-color: rgba(255, 255, 255, 0.15);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      }

      #visitSiteButton:disabled {
        background: rgba(85, 85, 85, 0.3);
        color: #aaa;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      .layout-button {
        padding: 10px 16px;
        background-color: rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.9em;
        font-weight: 500;
        text-align: center;
        line-height: 1.3;
        flex-grow: 1;
        backdrop-filter: blur(6px);
        -webkit-backdrop-filter: blur(6px);
        transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        position: relative;
        overflow: hidden;
      }

      .layout-button::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        width: 100%;
        height: 100%;
        background: radial-gradient(
          circle,
          rgba(255, 255, 255, 0.2) 0%,
          rgba(255, 255, 255, 0) 70%
        );
        border-radius: inherit;
        opacity: 0;
        transition: transform 0.4s ease-out, opacity 0.4s ease-out;
      }

      .layout-button:hover {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.6);
        transform: translateY(-2px);
        box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
      }

      .layout-button:hover::before {
        transform: translate(-50%, -50%) scale(1.5);
        opacity: 1;
      }

      .layout-button:active {
        transform: translateY(0px) scale(0.97);
        background-color: rgba(255, 255, 255, 0.15);
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      }

      .layout-button.active {
        background: linear-gradient(
          45deg,
          rgba(0, 220, 220, 0.6),
          rgba(0, 180, 255, 0.7)
        );
        color: white;
        font-weight: 700;
        border: 1px solid rgba(0, 200, 255, 0.8);
        box-shadow: 0 0 12px rgba(0, 200, 255, 0.4),
          0 3px 8px rgba(0, 0, 0, 0.2);
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
      }

      #layoutControls > div {
        gap: 10px;
      }
      .layout-button i {
        font-size: 1.2em;
      }

      @media (max-width: 768px) {
        #selectedItemPanel {
          max-width: 150px; /* 모바일 최대 너비 */
        }
        #selectedItemImage {
          max-height: 150px; /* 모바일 최대 높이 */
        }
      }
    </style>
  </head>
  <body>
    <div id="controlsContainer">
      <div id="controls">
        <img
          id="logoImage"
          src="https://i.imgur.com/fgJ3rAV.png"
          alt="May I 2D Logo"
        />

        <div>
          <input type="color" id="bgColorPicker" value="#000000" />
        </div>

        <div
          id="layoutControls"
          style="
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
          "
        >
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px">
            <button
              class="layout-button active"
              data-layout="wavegrid"
              title="Wave Grid"
            >
              Grid
            </button>
            <button class="layout-button" data-layout="sphere" title="Sphere">
              Sphere
            </button>
            <button class="layout-button" data-layout="flow" title="Flow">
              Free
            </button>
            <button
              class="layout-button"
              data-layout="panorama"
              title="Panorama"
            >
              View
            </button>
          </div>
        </div>

        <div id="selectedItemPanel">
          <img id="selectedItemImage" src="" alt="Selected product image" />
          <button id="visitSiteButton" data-url="">Materialize</button>
        </div>
      </div>
      <button id="toggleControlsButton">☰</button>
    </div>

    <div id="loader">Loading... 0%</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      // import { SimplexNoise } from 'three/addons/math/SimplexNoise.js'; // If using Three's built-in
      // Or import from the separate library you included, e.g.:
      // const simplex = new SimplexNoise(); // You'll need to include a noise library

      const CONFIG = {
        IMAGE_OBJECT_COUNT: 200,
        SPREAD_RANGE: 60, // Used for Random and Flow initial spread
        DEFAULT_BG_COLOR: "#000000",
        HOVER_SCALE_FACTOR: 1.2,
        CLICK_PLANE_SCALE: 1.5, // Scale factor for the invisible raycast plane
        isMobile:
          /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
            navigator.userAgent
          ),
        CAMERA: {
          MOBILE: { Z: 55, MIN_DISTANCE: 15, MAX_DISTANCE: 120 },
          DESKTOP: { Z: 40, MIN_DISTANCE: 5, MAX_DISTANCE: 100 },
        },
        LIGHT: {
          AMBIENT: { COLOR: 0x808080, INTENSITY: 1.8 },
          POINT: {
            COLORS: [0xffaa00, 0x00aaff, 0xff00ff, 0xaaffaa],
            INTENSITY: 2.5,
            DISTANCE: 100,
            DECAY: 1.5,
          },
        },
        ANIMATION: {
          THROTTLE: 16, // ms between pointer move updates
          ROTATION_SPEED: 0.002, // Base rotation for random layout
          TRANSITION_DURATION: 1.5, // seconds for layout change
          // --- Add specific animation params ---
          GRID_IDLE_ROT_SPEED: 0.03,
          SPIRAL_STRUCT_ROT_SPEED: 0.02,
          SPIRAL_SELF_ROT_SPEED: 0.1,
        },
        PARTICLES: {
          DESKTOP_COUNT: 7000,
          MOBILE_COUNT: 3000,
          SPREAD_RADIUS: 150,
        },
        LAYOUT: {
          SPHERE: {
            RADIUS: 25,
            SPREAD: 0.05, // Randomness factor for radius
            ORBIT_SPEED: 0.02, // Speed items orbit the center (0.01에서 0.02로 증가)
            SELF_ROTATION_SPEED: 0.05, // Speed items spin (0.03에서 0.05로 증가)
          },
          GRID: {
            COLUMNS: 10,
            SPACING: 4,
            POSITION_JITTER: 0.4,
            ROTATION_JITTER: 0.15,
          },
          SPIRAL: {
            RADIUS: 25,
            TURNS: 2.5,
            SPREAD: 0.1, // Radius randomness
            HEIGHT_FACTOR: 1.2, // How tall the spiral is
            WAVE_FREQ: 0.8, // Frequency of the up/down wave
            WAVE_AMP: 4.5, // Amplitude of the up/down wave
          },
          RANDOM: {
            SPREAD: 0.05, // Not used directly, SPREAD_RANGE defines area
            FLOAT_AMPLITUDE: 0.1,
            FLOAT_SPEED: 0.1,
          },
          // --- New Layout Configs ---
          FLOW: {
            NOISE_SCALE: 0.1, // 더 부드럽고 자연스러운 흐름을 위해 낮춤
            SPEED: 0.06, // 패턴 변화를 적절한 속도로 조정
            FORCE: 0.9, // 움직임의 강도를 자연스럽게 조정
            ROTATION_DAMPING: 0.97, // 회전을 더 부드럽게
            MAX_SPEED: 0.6, // 최대 속도를 적절하게 조정
          },
          WAVEGRID: {
            // Inherits Grid settings for base layout
            EFFECT_RADIUS: 15.0, // How far the mouse wave reaches
            MAX_DISPLACEMENT: 2.0, // Max Z displacement
            WAVE_SPEED: 3.0, // How fast the wave ripples
            DAMPING: 0.9, // How quickly items return to base position (lower = slower)
          },
          PANORAMA: {
            NUM_LAYERS: 5, // 레이어 수를 5개로 증가
            LAYER_DEPTH: 10.0, // 레이어 간 거리를 더 줄여서 5개 레이어에 맞게 조정
            RADIUS: 28.0, // 반경을 약각 줄여서 5개 레이어에 맞게 조정
            ITEM_SPACING_X: 3.2, // 아이템 간 간격을 조정
            ITEM_SPACING_Y: 3.2,
            ARRANGEMENT: "cylindrical",
            PARALLAX_FACTOR: 0.08, // 패럴랙스 효과를 더 강화
            LAYER_ROTATION_SPEED: 0.015, // 회전 속도를 더 빠르게 조정
            LAYER_OSCILLATION: {
              // 레이어별 진동 효과 조정
              AMPLITUDE: 0.6,
              FREQUENCY: 0.4,
            },
          },
        },
      };

      // --- Product Data (Keep as is) ---
      const products = [
        /* ... Your product list remains unchanged ... */
        {
          imageUrl: "https://i.imgur.com/px60C11.png",
          purchaseUrl: "https://mayi2d.shop/products/rose-little-prince",
        },
        {
          imageUrl: "https://i.imgur.com/eqcLGF6.png",
          purchaseUrl: "https://mayi2d.shop/products/amen%F0%9F%99%8F",
        },
        {
          imageUrl: "https://i.imgur.com/xU7TS58.png",
          purchaseUrl: "https://mayi2d.shop/products/sweet-panda",
        },
        {
          imageUrl: "https://i.imgur.com/5b9EsGB.png",
          purchaseUrl: "https://mayi2d.shop/products/black-punk- skull",
        },
        {
          imageUrl: "https://i.imgur.com/bPXsjAw.png",
          purchaseUrl: "https://mayi2d.shop/products/money-shape",
        },
        {
          imageUrl: "https://i.imgur.com/GETdAiE.png",
          purchaseUrl: "https://mayi2d.shop/products/bread-series",
        },
        {
          imageUrl: "https://i.imgur.com/Yz7dBh7.png",
          purchaseUrl:
            "https://mayi2d.shop/products/dinosaur-nugget-and-ketchup",
        },
        {
          imageUrl: "https://i.imgur.com/1LF0lQF.png",
          purchaseUrl: "https://mayi2d.shop/products/lab-mouse",
        },
        {
          imageUrl: "https://i.imgur.com/HNLaeRM.png",
          purchaseUrl: "https://mayi2d.shop/products/lab-flask-plants",
        },
        {
          imageUrl: "https://i.imgur.com/xi6EnkF.png",
          purchaseUrl: "https://mayi2d.shop/products/alien-green-cat-ufo",
        },
        {
          imageUrl: "https://i.imgur.com/sllSsvG.png",
          purchaseUrl: "https://mayi2d.shop/products/im-rock",
        },
        {
          imageUrl: "https://i.imgur.com/gA6lWEj.png",
          purchaseUrl:
            "https://mayi2d.shop/products/soooo-cute-dinosaur-%F0%9F%91%BE",
        },
        {
          imageUrl: "https://i.imgur.com/lRt2Uqw.png",
          purchaseUrl: "http://mayi2d.shop/products/beetles",
        },
        {
          imageUrl: "https://i.imgur.com/gAhjsnt.png",
          purchaseUrl: "https://mayi2d.shop/products/one-eyed-mon",
        },
        {
          imageUrl: "https://i.imgur.com/m7fDSk8.png",
          purchaseUrl:
            "https://mayi2d.shop/products/radioactive-radiation-labeling",
        },
        {
          imageUrl: "https://i.imgur.com/lqjsDYn.png",
          purchaseUrl:
            "https://mayi2d.shop/products/marine-creatures%F0%9F%90%9A",
        },
        {
          imageUrl: "https://i.imgur.com/sHcbpIm.png",
          purchaseUrl: "https://mayi2d.shop/products/black-white-day",
        },
        {
          imageUrl: "https://i.imgur.com/HIh73o1.png",
          purchaseUrl: "https://mayi2d.shop/products/lazying-cat",
        },
        {
          imageUrl: "https://i.imgur.com/wLvfLgH.png",
          purchaseUrl: "https://mayi2d.shop/products/fluffy-penguin-lettering",
        },
        {
          imageUrl: "https://i.imgur.com/mSUxi9J.png",
          purchaseUrl: "https://mayi2d.shop/products/gas-mask",
        },
        {
          imageUrl: "https://i.imgur.com/Cg1z4B7.png",
          purchaseUrl: "https://mayi2d.shop/products/green-frog-on-stool",
        },
        {
          imageUrl: "https://i.imgur.com/N5XMO80.png",
          purchaseUrl: "https://mayi2d.shop/products/fire-helllmo",
        },
        {
          imageUrl: "https://i.imgur.com/p8SCKt6.png",
          purchaseUrl: "https://mayi2d.shop/products/honk-honk",
        },
        {
          imageUrl: "https://i.imgur.com/k7lFI9V.png",
          purchaseUrl: "https://mayi2d.shop/products/punk-skull",
        },
        {
          imageUrl: "https://i.imgur.com/GKfk2sx.png",
          purchaseUrl: "https://mayi2d.shop/products/shotguns",
        },
        {
          imageUrl: "https://i.imgur.com/YFUaw45.png",
          purchaseUrl: "https://mayi2d.shop/products/wings-eye",
        },
        {
          imageUrl: "https://i.imgur.com/W7kVc9D.png",
          purchaseUrl: "https://mayi2d.shop/products/magic-potion",
        },
        {
          imageUrl: "https://i.imgur.com/ohX7Kk0.png",
          purchaseUrl: "https://mayi2d.shop/products/pool-boby",
        },
        {
          imageUrl: "https://i.imgur.com/9GLdv8S.png",
          purchaseUrl: "https://mayi2d.shop/products/mystery-stuff",
        },
        {
          imageUrl: "https://i.imgur.com/mywFTuJ.png",
          purchaseUrl: "https://mayi2d.shop/products/luna-eye",
        },
        {
          imageUrl: "https://i.imgur.com/u0Zax2J.png",
          purchaseUrl: "https://mayi2d.shop/products/triple-bus",
        },
        {
          imageUrl: "https://i.imgur.com/LZK48F5.png",
          purchaseUrl: "https://mayi2d.shop/products/space-company",
        },
        {
          imageUrl: "https://i.imgur.com/7pJLecy.png",
          purchaseUrl: "https://mayi2d.shop/products/pumpkin-friends",
        },
        {
          imageUrl: "https://i.imgur.com/hgr5Fgw.png",
          purchaseUrl: "https://mayi2d.shop/products/i-did-it",
        },
        {
          imageUrl: "https://i.imgur.com/tY2g0wr.png",
          purchaseUrl: "https://mayi2d.shop/products/romance-pin",
        },
        {
          imageUrl: "https://i.imgur.com/ZnKfEt1.png",
          purchaseUrl: "https://mayi2d.shop/products/coffee-pumpkin",
        },
        {
          imageUrl: "https://i.imgur.com/5g5pJBb.png",
          purchaseUrl: "https://mayi2d.shop/products/pink-slime",
        },
        {
          imageUrl: "https://i.imgur.com/nwUPDLq.png",
          purchaseUrl: "https://mayi2d.shop/products/ticket",
        },
        {
          imageUrl: "https://i.imgur.com/l1Enik5.png",
          purchaseUrl: "https://mayi2d.shop/products/insam",
        },
        {
          imageUrl: "https://i.imgur.com/0cr9Tpx.png",
          purchaseUrl: "https://mayi2d.shop/products/science-brooches",
        },
        {
          imageUrl: "https://i.imgur.com/Gn8rTId.png",
          purchaseUrl: "https://mayi2d.shop/products/sports-star-uniform",
        },
        {
          imageUrl: "https://i.imgur.com/IeORQvd.png",
          purchaseUrl: "https://mayi2d.shop/products/startled-cat",
        },
        {
          imageUrl: "https://i.imgur.com/lAa6rbg.png",
          purchaseUrl: "https://mayi2d.shop/products/meow-cat-keychain-luck-1",
        },
        {
          imageUrl: "https://i.imgur.com/7votial.png",
          purchaseUrl: "https://mayi2d.shop/products/sad-hamster-key-chain",
        },
        {
          imageUrl: "https://i.imgur.com/INNoWiQ.png",
          purchaseUrl: "https://mayi2d.shop/products/stronger-than-you-think",
        },
        {
          imageUrl: "https://i.imgur.com/HYDjwO6.png",
          purchaseUrl: "https://mayi2d.shop/products/movie-car",
        },
        {
          imageUrl: "https://i.imgur.com/kQ6YI7e.png",
          purchaseUrl: "https://mayi2d.shop/products/punk-skull-symbol",
        },
        {
          imageUrl: "https://i.imgur.com/KoAL6XJ.png",
          purchaseUrl: "https://mayi2d.shop/products/punisher-skull",
        },
        {
          imageUrl: "https://i.imgur.com/wTFSY5N.png",
          purchaseUrl: "https://mayi2d.shop/products/skull-of-rock",
        },
        {
          imageUrl: "https://i.imgur.com/tXsQz9f.png",
          purchaseUrl: "https://mayi2d.shop/products/gold-47",
        },
        {
          imageUrl: "https://i.imgur.com/Jkb1XgY.png",
          purchaseUrl: "https://mayi2d.shop/products/glock-z",
        },
        {
          imageUrl: "https://i.imgur.com/DRpZAg2.png",
          purchaseUrl: "https://mayi2d.shop/products/just-life",
        },
        {
          imageUrl: "https://i.imgur.com/QcUVzYZ.png",
          purchaseUrl: "https://mayi2d.shop/products/green-plant-animal-face",
        },
        {
          imageUrl: "https://i.imgur.com/Duz6x1z.png",
          purchaseUrl: "https://mayi2d.shop/products/vegetarian-bottle",
        },
        {
          imageUrl: "https://i.imgur.com/n2y5M5O.png",
          purchaseUrl: "https://mayi2d.shop/products/pink-joint",
        },
        {
          imageUrl: "https://i.imgur.com/kErgX0i.png",
          purchaseUrl: "https://mayi2d.shop/products/1-minute-later",
        },
        {
          imageUrl: "https://i.imgur.com/jnQKuCP.png",
          purchaseUrl: "https://mayi2d.shop/products/coral-reef-j",
        },
        {
          imageUrl: "https://i.imgur.com/K25eeaD.png",
          purchaseUrl: "https://mayi2d.shop/products/daisy-bong",
        },
        {
          imageUrl: "https://i.imgur.com/r8ECoPz.png",
          purchaseUrl: "https://mayi2d.shop/products/hungry-larva",
        },
        {
          imageUrl: "https://i.imgur.com/9UeUROm.png",
          purchaseUrl: "https://mayi2d.shop/products/sunday-cupcake",
        },
        {
          imageUrl: "https://i.imgur.com/OzerZT3.png",
          purchaseUrl: "https://mayi2d.shop/products/human-organ-bottle",
        },
        {
          imageUrl: "https://i.imgur.com/Ru0Xgz7.png",
          purchaseUrl: "https://mayi2d.shop/products/need-more-coffee",
        },
        {
          imageUrl: "https://i.imgur.com/p52R6HC.png",
          purchaseUrl: "https://mayi2d.shop/products/pink-portal",
        },
        {
          imageUrl: "https://i.imgur.com/h0oqrIs.png",
          purchaseUrl: "https://mayi2d.shop/products/girl-power%F0%9F%8C%9F",
        },
        {
          imageUrl: "https://i.imgur.com/BJkmLGm.png",
          purchaseUrl: "https://mayi2d.shop/products/colored-painting-brush",
        },
        {
          imageUrl: "https://i.imgur.com/2xwHP9f.png",
          purchaseUrl: "https://mayi2d.shop/products/women-belong-in-the-lab",
        },
        {
          imageUrl: "https://i.imgur.com/i4erGhU.png",
          purchaseUrl: "https://mayi2d.shop/products/feeling-goods-good-enough",
        },
        {
          imageUrl: "https://i.imgur.com/Zx4kwTX.png",
          purchaseUrl: "https://mayi2d.shop/products/you-are-the-dancing-queen",
        },
        {
          imageUrl: "https://i.imgur.com/oAKjGrr.png",
          purchaseUrl: "https://mayi2d.shop/products/angel-love",
        },
        {
          imageUrl: "https://i.imgur.com/gC2kQjV.png",
          purchaseUrl: "https://mayi2d.shop/products/burning-dice-%F0%9F%94%A5",
        },
        {
          imageUrl: "https://i.imgur.com/idF7VmU.png",
          purchaseUrl:
            "https://mayi2d.shop/products/strawberries-basket-%F0%9F%8D%93",
        },
        {
          imageUrl: "https://i.imgur.com/9LOM18S.png",
          purchaseUrl: "https://mayi2d.shop/products/cheeze-alien-%F0%9F%91%BD",
        },
        {
          imageUrl: "https://i.imgur.com/kPXg6nF.png",
          purchaseUrl: "https://mayi2d.shop/products/wtf",
        },
        {
          imageUrl: "https://i.imgur.com/Lui16w2.png",
          purchaseUrl: "https://mayi2d.shop/products/the-future-is-bright",
        },
        {
          imageUrl: "https://i.imgur.com/NISHMQM.png",
          purchaseUrl: "https://mayi2d.shop/products/purple-room",
        },
        {
          imageUrl: "https://i.imgur.com/RFgtNCw.png",
          purchaseUrl: "https://mayi2d.shop/products/legend-punk",
        },
        {
          imageUrl: "https://i.imgur.com/AQKHdX4.png",
          purchaseUrl:
            "https://mayi2d.shop/products/i-tolerate-many-things-but-i-cant-tolerate-bran",
        },
        {
          imageUrl: "https://i.imgur.com/lCDwzqg.png",
          purchaseUrl: "https://mayi2d.shop/products/dear-me",
        },
        {
          imageUrl: "https://i.imgur.com/A2bDvb5.png",
          purchaseUrl: "https://mayi2d.shop/products/cow-duck",
        },
        {
          imageUrl: "https://i.imgur.com/vUs3ezp.png",
          purchaseUrl: "https://mayi2d.shop/products/red-oni",
        },
        {
          imageUrl: "https://i.imgur.com/fXbc49J.png",
          purchaseUrl: "https://mayi2d.shop/products/skeleton-cat-disco",
        },
        {
          imageUrl: "https://i.imgur.com/hqZTWIb.png",
          purchaseUrl: "https://mayi2d.shop/products/im-doing-side-quests",
        },
        {
          imageUrl: "https://i.imgur.com/6PL3QQU.png",
          purchaseUrl: "https://mayi2d.shop/products/la-blue-ice",
        },
        {
          imageUrl: "https://i.imgur.com/y0PKlj4.png",
          purchaseUrl: "https://mayi2d.shop/products/wah",
        },
        {
          imageUrl: "https://i.imgur.com/bVGIDwp.png",
          purchaseUrl: "https://mayi2d.shop/products/see-house",
        },
        {
          imageUrl: "https://i.imgur.com/ECUPs7R.png",
          purchaseUrl: "https://mayi2d.shop/products/warrior-pin",
        },
        {
          imageUrl: "https://i.imgur.com/Wh4lBna.png",
          purchaseUrl: "https://mayi2d.shop/products/its-just-a-flesh-wound",
        },
        {
          imageUrl: "https://i.imgur.com/ScKhQ3y.png",
          purchaseUrl: "https://mayi2d.shop/products/cat-with-knife",
        },
        {
          imageUrl: "https://i.imgur.com/prXigEi.png",
          purchaseUrl:
            "https://mayi2d.shop/products/lucky-swords-%F0%9F%97%A1%EF%B8%8F",
        },
        {
          imageUrl: "https://i.imgur.com/Ab6SXOT.png",
          purchaseUrl: "https://mayi2d.shop/products/ranger-mask",
        },
        {
          imageUrl: "https://i.imgur.com/L8sqXwg.png",
          purchaseUrl: "https://mayi2d.shop/products/pink-mouse",
        },
        {
          imageUrl: "https://i.imgur.com/uTE8O4b.png",
          purchaseUrl: "https://mayi2d.shop/products/dr-peepee",
        },
        {
          imageUrl: "https://i.imgur.com/erHLzLb.png",
          purchaseUrl: "https://mayi2d.shop/products/seraph-cat-wings",
        },
        {
          imageUrl: "https://i.imgur.com/rvCx8ym.png",
          purchaseUrl: "https://mayi2d.shop/products/nugs-not-drugs",
        },
        {
          imageUrl: "https://i.imgur.com/rC6BEDK.png",
          purchaseUrl: "https://mayi2d.shop/products/boy-money",
        },
        {
          imageUrl: "https://i.imgur.com/MswTpby.png",
          purchaseUrl: "https://mayi2d.shop/products/pink-pistol",
        },
        {
          imageUrl: "https://i.imgur.com/PrGSHhP.png",
          purchaseUrl: "https://mayi2d.shop/products/goose-goose-drive",
        },
        {
          imageUrl: "https://i.imgur.com/SZyg85x.png",
          purchaseUrl: "https://mayi2d.shop/products/our-rainy-night-together",
        },
        {
          imageUrl: "https://i.imgur.com/Vf1l8lS.png",
          purchaseUrl: "https://mayi2d.shop/products/dance-frog",
        },
        {
          imageUrl: "https://i.imgur.com/vJrzH8u.png",
          purchaseUrl: "https://mayi2d.shop/products/really",
        },
        {
          imageUrl: "https://i.imgur.com/LXVPdzZ.png",
          purchaseUrl: "https://mayi2d.shop/products/fibonacci",
        },
        {
          imageUrl: "https://i.imgur.com/Lmq94tj.png",
          purchaseUrl:
            "https://mayi2d.shop/products/something-that-makes-you-zone-out",
        },
        {
          imageUrl: "https://i.imgur.com/pDdxXoB.png",
          purchaseUrl: "https://mayi2d.shop/products/as-it-sways",
        },
        {
          imageUrl: "https://i.imgur.com/jyMoju7.png",
          purchaseUrl: "https://mayi2d.shop/products/wiggly-jellyfish",
        },
        {
          imageUrl: "https://i.imgur.com/Rlqrs0r.png",
          purchaseUrl: "https://mayi2d.shop/products/believe-me-im-not-a-ghost",
        },
        {
          imageUrl: "https://i.imgur.com/AJFTPXF.png",
          purchaseUrl:
            "https://mayi2d.shop/products/teetering-between-despair-and-darkness",
        },
        {
          imageUrl: "https://i.imgur.com/yS0fYU6.png",
          purchaseUrl:
            "https://mayi2d.shop/products/an-elephant-with-octopus-tentacles",
        },
        {
          imageUrl: "https://i.imgur.com/xJMg5zj.png",
          purchaseUrl: "https://mayi2d.shop/products/two-birds",
        },
        {
          imageUrl: "https://i.imgur.com/e4MBcKm.png",
          purchaseUrl: "https://mayi2d.shop/products/blue-bird",
        },
        {
          imageUrl: "https://i.imgur.com/7gHToMe.png",
          purchaseUrl: "https://mayi2d.shop/products/mushroom-enamel-pin",
        },
        {
          imageUrl: "https://i.imgur.com/GbgorJV.png",
          purchaseUrl:
            "https://mayi2d.shop/products/inspiration-old-pawn-indian-fred-bird",
        },
        {
          imageUrl: "https://i.imgur.com/XmtTrNd.png",
          purchaseUrl: "https://mayi2d.shop/products/with-hands-joined",
        },
        {
          imageUrl: "https://i.imgur.com/SZyvd09.png",
          purchaseUrl: "https://mayi2d.shop/products/neuron-potential",
        },
        {
          imageUrl: "https://i.imgur.com/chrFVib.png",
          purchaseUrl: "https://mayi2d.shop/products/peaceful-clouds",
        },
        {
          imageUrl: "https://i.imgur.com/pukx8C1.png",
          purchaseUrl: "https://mayi2d.shop/products/black-love",
        },
        {
          imageUrl: "https://i.imgur.com/rkb5zVw.png",
          purchaseUrl:
            "https://mayi2d.shop/products/surprisingly-its-not-an-ancient-artifact-just-a-book-that-looks-like-one",
        },
        {
          imageUrl: "https://i.imgur.com/NKirQGP.png",
          purchaseUrl: "https://mayi2d.shop/products/round-muzzle",
        },
        {
          imageUrl: "https://i.imgur.com/VDwCUKT.png",
          purchaseUrl: "https://mayi2d.shop/products/eagerly-hand",
        },
        {
          imageUrl: "https://i.imgur.com/keoxIUK.png",
          purchaseUrl: "https://mayi2d.shop/products/hippie-bus",
        },
        {
          imageUrl: "https://i.imgur.com/7ii0Pe2.png",
          purchaseUrl: "https://mayi2d.shop/products/elephant-boho",
        },
        {
          imageUrl: "https://i.imgur.com/JcUnlYc.png",
          purchaseUrl: "https://mayi2d.shop/products/smile-lsd",
        },
        {
          imageUrl: "https://i.imgur.com/jHj47lu.png",
          purchaseUrl: "https://mayi2d.shop/products/the-astronaut",
        },
        {
          imageUrl: "https://i.imgur.com/nr82kuE.png",
          purchaseUrl: "https://mayi2d.shop/products/ninja-chakra",
        },
        {
          imageUrl: "https://i.imgur.com/q8I54Z4.png",
          purchaseUrl:
            "https://mayi2d.shop/products/my-anxieties-have-anxieties",
        },
        {
          imageUrl: "https://i.imgur.com/mEOKviv.png",
          purchaseUrl: "https://mayi2d.shop/products/gotham-city",
        },
        {
          imageUrl: "https://i.imgur.com/Q9kLNeZ.png",
          purchaseUrl: "https://mayi2d.shop/products/fire-demon-set",
        },
        {
          imageUrl: "https://i.imgur.com/F5o1tKT.png",
          purchaseUrl: "https://mayi2d.shop/products/lovely-cats",
        },
        {
          imageUrl: "https://i.imgur.com/S95fvPl.png",
          purchaseUrl: "https://mayi2d.shop/products/lab-mouse-1",
        },
        {
          imageUrl: "https://i.imgur.com/t0yrawI.png",
          purchaseUrl: "https://mayi2d.shop/products/angry-red-rabbit",
        },
        {
          imageUrl: "https://i.imgur.com/k5hTHgQ.png",
          purchaseUrl: "https://mayi2d.shop/products/money-shape-1",
        },
        {
          imageUrl: "https://i.imgur.com/E3EEICL.png",
          purchaseUrl: "https://mayi2d.shop/products/rstar",
        },
        {
          imageUrl: "https://i.imgur.com/9NPdoEy.png",
          purchaseUrl: "https://mayi2d.shop/products/btc",
        },
        {
          imageUrl: "https://i.imgur.com/1jPRCDP.png",
          purchaseUrl: "https://mayi2d.shop/products/skull-candy",
        },
        {
          imageUrl: "https://i.imgur.com/vzUt3ke.jpeg",
          purchaseUrl: "https://mayi2d.shop/products/i-tried",
        },
        {
          imageUrl: "https://i.imgur.com/AsePceB.png",
          purchaseUrl: "https://mayi2d.shop/products/cat-card",
        },
        {
          imageUrl: "https://i.imgur.com/FjDKimK.png",
          purchaseUrl: "https://mayi2d.shop/products/this-is-fine",
        },
        {
          imageUrl: "https://i.imgur.com/9eEg1rP.png",
          purchaseUrl: "https://mayi2d.shop/products/metal-chariot",
        },
        {
          imageUrl: "https://i.imgur.com/N16f6kc.png",
          purchaseUrl: "https://mayi2d.shop/products/2050-knightmare",
        },
        {
          imageUrl: "https://i.imgur.com/9YAm1Ms.png",
          purchaseUrl: "https://mayi2d.shop/products/let-it-burn",
        },
        {
          imageUrl: "https://i.imgur.com/EFSH1Lz.png",
          purchaseUrl: "https://mayi2d.shop/products/1am-ramen",
        },
        {
          imageUrl: "https://i.imgur.com/zbw1jyf.png",
          purchaseUrl: "https://mayi2d.shop/products/dinosaur-bongbong",
        },
        {
          imageUrl: "https://i.imgur.com/4iDj0kV.png",
          purchaseUrl: "https://mayi2d.shop/products/%E2%9C%9D%EF%B8%8F",
        },
        {
          imageUrl: "https://i.imgur.com/QWFdy2r.png",
          purchaseUrl: "https://mayi2d.shop/products/jesus-band",
        },
        {
          imageUrl: "https://i.imgur.com/0zfAn9S.png",
          purchaseUrl: "https://mayi2d.shop/products/cute-chameleon",
        },
        {
          imageUrl: "https://i.imgur.com/rPofAT4.png",
          purchaseUrl: "https://mayi2d.shop/products/pathetically-sad-cat",
        },
        {
          imageUrl: "https://i.imgur.com/fOOL18m.png",
          purchaseUrl: "https://mayi2d.shop/products/emblem-of-divinity",
        },
        {
          imageUrl: "https://i.imgur.com/FAsrboW.png",
          purchaseUrl: "https://mayi2d.shop/products/the-fluid-forest-tracker",
        },
        {
          imageUrl: "https://i.imgur.com/0LSeR4p.png",
          purchaseUrl: "https://mayi2d.shop/products/floral-cutie-alien",
        },
        {
          imageUrl: "https://i.imgur.com/RP9RFbQ.png",
          purchaseUrl: "https://mayi2d.shop/products/super-smash-bros",
        },
        {
          imageUrl: "https://i.imgur.com/5AdYmGl.png",
          purchaseUrl: "https://mayi2d.shop/products/sweet-duck",
        },
        {
          imageUrl: "https://i.imgur.com/GMKwIQe.png",
          purchaseUrl: "https://mayi2d.shop/products/re-1",
        },
        {
          imageUrl: "https://i.imgur.com/kYitjLJ.png",
          purchaseUrl: "https://mayi2d.shop/products/3d-game",
        },
        {
          imageUrl: "https://i.imgur.com/B9rHIAF.png",
          purchaseUrl: "https://mayi2d.shop/products/silly-juice",
        },
        {
          imageUrl: "https://i.imgur.com/oXCvczU.png",
          purchaseUrl:
            "https://mayi2d.shop/products/came-across-some-green-crocs",
        },
        {
          imageUrl: "https://i.imgur.com/hLI1zgx.png",
          purchaseUrl: "https://mayi2d.shop/products/white-warrior",
        },
        {
          imageUrl: "https://i.imgur.com/J13vxdy.png",
          purchaseUrl: "https://mayi2d.shop/products/animal-pin",
        },
        {
          imageUrl: "https://i.imgur.com/mtnb81v.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/Xsa2DmF.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/mvn1RRw.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/UYyZi89.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/Tu7B9t4.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/rYZxLEl.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/pmYZnAD.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/zEWGkkm.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/AtIkq6X.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
        {
          imageUrl: "https://i.imgur.com/RxVUfe0.png",
          purchaseUrl: "https://mayi2d.shop/",
        },
      ];

      let scene, camera, renderer, controls;
      const instancedMeshes = [];
      const raycastMeshes = [];
      const instanceData = []; // Stores data for each logical instance
      const pointLights = [];
      let backgroundLight, backLight;
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2(); // Normalized device coordinates (-1 to +1)
      let INTERSECTED_INFO = null; // { originalIndex, meshGroup, localInstanceId }
      const clock = new THREE.Clock();
      const textureCache = new Map();
      let sharedPlaneGeometry, sharedRaycastGeometry, sharedRaycastMaterial;
      let texturesLoaded = 0;
      let totalTexturesToLoad = 0;
      let particleSystem;
      const hoverColor = new THREE.Color(1, 1, 0.6); // Yellowish tint on hover
      const normalColor = new THREE.Color(1, 1, 1); // Default color
      let isMobile = false;
      let currentLayout = "sphere"; // Default layout
      let transitionStartTime = 0;
      let isTransitioning = false;
      let startPositions = []; // Array of { x, y, z, quaternion }
      let targetPositions = []; // Array of { x, y, z, quaternion, [optional layout specific data] }

      // DOM Elements
      const bgColorPicker = document.getElementById("bgColorPicker");
      const controlsElement = document.getElementById("controls");
      const controlsContainer = document.getElementById("controlsContainer");
      const toggleControlsButton = document.getElementById(
        "toggleControlsButton"
      );
      const selectedItemPanel = document.getElementById("selectedItemPanel");
      const selectedItemImage = document.getElementById("selectedItemImage");
      const visitSiteButton = document.getElementById("visitSiteButton");
      const loaderElement = document.getElementById("loader");
      const logoImageElement = document.getElementById("logoImage");

      // Reusable Three.js objects
      const tempMatrix = new THREE.Matrix4();
      const tempObject = new THREE.Object3D(); // For calculations involving position/rotation
      const tempPosition = new THREE.Vector3();
      const tempQuaternion = new THREE.Quaternion();
      const tempScale = new THREE.Vector3(1, 1, 1);
      const hoverScaleVec = new THREE.Vector3(
        CONFIG.HOVER_SCALE_FACTOR,
        CONFIG.HOVER_SCALE_FACTOR,
        CONFIG.HOVER_SCALE_FACTOR
      );
      const normalScaleVec = new THREE.Vector3(1, 1, 1);
      const pointerWorldPosition = new THREE.Vector3(); // For Wave Grid interaction
      const raycastPlane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Invisible plane at Z=0 for raycasting

      // Noise 함수 라이브러리 초기화
      const simplex = new SimplexNoise(); // 라이브러리 인스턴스 생성
      const noise = {
        // 실제 simplex.noise3D 함수를 연결
        simplex3: (x, y, z) => simplex.noise3D(x, y, z),
        // 필요하다면 2D 노이즈도 연결
        simplex2: (x, y) => simplex.noise2D(x, y),
      };

      init();
      animate();

      async function init() {
        try {
          // Logo setup
          if (logoImageElement) {
            logoImageElement.src = "https://i.imgur.com/fgJ3rAV.png"; // Your logo URL
            logoImageElement.style.cursor = "pointer"; // 커서를 포인터로 변경
            logoImageElement.addEventListener("click", () => {
              window.open("https://mayi2d.shop", "_blank"); // 새 탭에서 열기
            });
          }

          // Scene setup
          scene = new THREE.Scene();
          scene.fog = new THREE.FogExp2(
            new THREE.Color(CONFIG.DEFAULT_BG_COLOR).getHex(),
            0.01 // Fog density
          );

          // Detect mobile
          isMobile =
            /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) ||
            window.innerWidth <= 768;

          // Camera setup
          camera = new THREE.PerspectiveCamera(
            75, // Field of View
            window.innerWidth / window.innerHeight, // Aspect Ratio
            0.01, // Near clipping plane
            1000 // Far clipping plane
          );
          camera.position.z = isMobile
            ? CONFIG.CAMERA.MOBILE.Z
            : CONFIG.CAMERA.DESKTOP.Z;

          // Renderer setup
          renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: isMobile ? "low-power" : "high-performance",
          });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
          renderer.setClearColor(
            new THREE.Color(CONFIG.DEFAULT_BG_COLOR).getHex()
          );
          document.body.appendChild(renderer.domElement);

          // Controls setup
          controls = new OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.screenSpacePanning = false; // Panning moves camera in plane parallel to screen
          controls.minDistance = isMobile
            ? CONFIG.CAMERA.MOBILE.MIN_DISTANCE
            : CONFIG.CAMERA.DESKTOP.MIN_DISTANCE;
          controls.maxDistance = isMobile
            ? CONFIG.CAMERA.MOBILE.MAX_DISTANCE
            : CONFIG.CAMERA.DESKTOP.MAX_DISTANCE;
          controls.enableZoom = true;
          controls.enablePan = !isMobile; // Disable panning on mobile for better touch rotation

          // Lighting setup
          const ambientLight = new THREE.AmbientLight(
            CONFIG.LIGHT.AMBIENT.COLOR,
            CONFIG.LIGHT.AMBIENT.INTENSITY
          );
          scene.add(ambientLight);

          // Background Directional Light 추가
          const backgroundDirectionalLight = new THREE.DirectionalLight(
            0xffffff,
            1.5
          );
          backgroundDirectionalLight.position.set(0, 0, -1);
          scene.add(backgroundDirectionalLight);

          // 배경 구 추가
          const backgroundSphereGeo = new THREE.SphereGeometry(150, 32, 32);
          const backgroundSphereMat = new THREE.MeshStandardMaterial({
            color: 0x2e0854,
            side: THREE.BackSide,
            metalness: 0.0,
            roughness: 0.03,
          });
          const backgroundSphere = new THREE.Mesh(
            backgroundSphereGeo,
            backgroundSphereMat
          );
          scene.add(backgroundSphere);

          // 추가 조명
          const topLight = new THREE.DirectionalLight(0xffffff, 0.5);
          topLight.position.set(0, 1, 0);
          scene.add(topLight);

          const sideLight = new THREE.DirectionalLight(0xffffff, 0.3);
          sideLight.position.set(1, 0, 0);
          scene.add(sideLight);

          // 추가 포인트 라이트
          const pointLight1 = new THREE.PointLight(0xffffff, 1.5, 200);
          pointLight1.position.set(0, 50, 50);
          scene.add(pointLight1);

          const pointLight2 = new THREE.PointLight(0xffffff, 1.5, 200);
          pointLight2.position.set(0, -50, -50);
          scene.add(pointLight2);

          // Background Point Lights (Subtle illumination)
          backgroundLight = new THREE.PointLight(0xffffff, 2.5, 200, 1.5);
          backgroundLight.position.set(0, 0, -100); // Behind the scene
          scene.add(backgroundLight);
          backLight = new THREE.PointLight(0xffffff, 1.5, 200, 1.5);
          backLight.position.set(0, 0, 100); // In front
          scene.add(backLight);

          // Dynamic Point Lights (Colored, moving lights)
          CONFIG.LIGHT.POINT.COLORS.forEach((color) => {
            const pointLight = new THREE.PointLight(
              color,
              CONFIG.LIGHT.POINT.INTENSITY,
              CONFIG.LIGHT.POINT.DISTANCE,
              CONFIG.LIGHT.POINT.DECAY
            );
            // Initial random position and animation parameters
            pointLight.position.set(
              (Math.random() - 0.5) * CONFIG.SPREAD_RANGE * 1.2,
              (Math.random() - 0.5) * CONFIG.SPREAD_RANGE * 1.2,
              (Math.random() - 0.5) * CONFIG.SPREAD_RANGE * 1.2
            );
            pointLight.userData = {
              angle: Math.random() * Math.PI * 2,
              radius: 10 + Math.random() * 20,
              speed:
                (Math.random() + 0.5) * 0.4 * (Math.random() > 0.5 ? 1 : -1),
              yOffset: (Math.random() - 0.5) * 15,
            };
            scene.add(pointLight);
            pointLights.push(pointLight);
          });

          // Particle System
          createParticles();

          // Shared Geometries & Materials
          sharedPlaneGeometry = new THREE.PlaneGeometry(2.5, 2.5); // Geometry for visible planes
          const clickPlaneScale = CONFIG.isMobile ? 1.7 : 1.5;
          sharedRaycastGeometry = new THREE.PlaneGeometry(
            2.5 * clickPlaneScale,
            2.5 * clickPlaneScale
          );
          sharedRaycastMaterial = new THREE.MeshBasicMaterial({
            visible: false, // Keep invisible
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.1, // Low opacity for debugging if needed
          });

          // Setup Instanced Meshes (Loads textures and creates instances)
          await setupGroupedInstances();

          // Setup Event Listeners
          setupEventListeners();

          // Initialize with the default layout (Grid)
          // Set initial active button state
          document
            .querySelectorAll(".layout-button")
            .forEach((btn) => btn.classList.remove("active"));
          document
            .querySelector(`.layout-button[data-layout="${currentLayout}"]`)
            ?.classList.add("active");
          // Apply initial layout positions without transition
          targetPositions = calculateTargetPositions(currentLayout);
          applyInstantLayout(targetPositions);
        } catch (error) {
          console.error("Initialization error:", error);
          showError("Error during initialization. Please refresh the page.");
          if (loaderElement) loaderElement.textContent = "Error!";
        }
      }

      function createParticles() {
        const particleCount = isMobile
          ? CONFIG.PARTICLES.MOBILE_COUNT
          : CONFIG.PARTICLES.DESKTOP_COUNT;
        const positions = new Float32Array(particleCount * 3);
        const particleSpreadRadius = CONFIG.PARTICLES.SPREAD_RADIUS;

        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          // Distribute particles within a sphere volume
          const u = Math.random();
          const v = Math.random();
          const theta = 2 * Math.PI * u; // Longitude
          const phi = Math.acos(2 * v - 1); // Latitude
          const r = Math.cbrt(Math.random()) * particleSpreadRadius; // Radius (cubic root for uniform volume distribution)

          positions[i3] = r * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = r * Math.cos(phi);
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );

        const material = new THREE.PointsMaterial({
          color: 0xffffff,
          size: isMobile ? 0.15 : 0.1,
          sizeAttenuation: true, // Points get smaller further away
          transparent: true,
          opacity: 0.75,
          depthWrite: false, // Avoid particles obscuring important objects
        });

        particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);
        console.log(`Particle system created with ${particleCount} particles.`);
      }

      async function setupGroupedInstances() {
        const loadingManager = new THREE.LoadingManager();
        texturesLoaded = 0;
        totalTexturesToLoad = 0;

        // Loading manager callbacks
        loadingManager.onProgress = (url, loaded, total) => {
          // console.log(`Loading texture: ${url}. Loaded ${loaded} of ${total}`);
        };
        loadingManager.onLoad = () => {
          console.log("All textures loaded via manager.");
          checkLoadingComplete(); // Check completion once manager says it's done
        };
        loadingManager.onError = (url) => {
          console.error("Error loading texture via manager:", url);
          // Assume texture failed, increment count to potentially finish loading state
          texturesLoaded++;
          updateLoaderProgress(texturesLoaded, totalTexturesToLoad);
          checkLoadingComplete();
        };

        const textureLoader = new THREE.TextureLoader(loadingManager);
        textureLoader.setCrossOrigin("anonymous"); // Handle CORS for images from other domains

        // Shuffle products to vary initial display
        const shuffledProducts = [...products].sort(() => Math.random() - 0.5);

        // Group instances by image URL to create fewer InstancedMesh objects
        const groupedInstances = new Map();
        for (let i = 0; i < CONFIG.IMAGE_OBJECT_COUNT; i++) {
          const productIndex = i % shuffledProducts.length; // Cycle through products
          const product = shuffledProducts[productIndex];

          if (!product || !product.imageUrl) {
            console.warn(`Skipping instance ${i}: Missing product or imageUrl`);
            continue;
          }

          // Initialize group if it doesn't exist
          if (!groupedInstances.has(product.imageUrl)) {
            groupedInstances.set(product.imageUrl, {
              product: product,
              originalIndices: [], // Store the original logical index (0 to IMAGE_OBJECT_COUNT-1)
            });
          }
          groupedInstances.get(product.imageUrl).originalIndices.push(i);

          // Initialize data structure for this logical instance
          instanceData[i] = {
            purchaseUrl: product.purchaseUrl,
            imageUrl: product.imageUrl,
            // -- Add state needed for specific layouts --
            velocity: new THREE.Vector3(), // For 'flow' layout
            angularVelocity: new THREE.Vector3(), // For 'flow' layout
            targetZ: 0, // For 'wavegrid' layout target z
            currentZOffset: 0, // For 'wavegrid' smooth animation
            layerIndex: 0, // For 'panorama' layout
            // -------------------------------------------
            visibleMeshGroup: null, // Reference to the InstancedMesh it belongs to
            raycastMeshGroup: null, // Reference to the corresponding raycast mesh
            localInstanceId: -1, // Index within its InstancedMesh group
          };
        }

        totalTexturesToLoad = groupedInstances.size;
        if (loaderElement)
          updateLoaderProgress(texturesLoaded, totalTexturesToLoad);

        const loadPromises = []; // Array to hold all texture loading promises

        // Iterate through grouped instances and create InstancedMesh for each group
        for (const [imageUrl, group] of groupedInstances.entries()) {
          const loadPromise = loadTexture(textureLoader, imageUrl)
            .then((texture) => {
              texturesLoaded++; // Increment loaded count on success
              updateLoaderProgress(texturesLoaded, totalTexturesToLoad);

              // --- Create Visible Instanced Mesh ---
              const visibleMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                side: THREE.DoubleSide,
                transparent: true,
                alphaTest: 0.1, // Discard pixels with low alpha (prevents black borders on PNGs)
                depthWrite: true, // Ensure correct depth sorting
              });
              const visibleMeshGroup = new THREE.InstancedMesh(
                sharedPlaneGeometry,
                visibleMaterial,
                group.originalIndices.length // Number of instances in this group
              );
              // Add color buffer for hover effect
              visibleMeshGroup.instanceColor =
                new THREE.InstancedBufferAttribute(
                  new Float32Array(group.originalIndices.length * 3),
                  3
                );
              for (let j = 0; j < group.originalIndices.length; j++) {
                visibleMeshGroup.setColorAt(j, normalColor); // Initialize with normal color
              }
              visibleMeshGroup.instanceColor.needsUpdate = true;
              visibleMeshGroup.userData.imageUrl = imageUrl; // Store URL for reference if needed
              scene.add(visibleMeshGroup);
              instancedMeshes.push(visibleMeshGroup);

              // --- Create Raycast Instanced Mesh (Invisible) ---
              const raycastMeshGroup = new THREE.InstancedMesh(
                sharedRaycastGeometry,
                sharedRaycastMaterial, // Uses the invisible material
                group.originalIndices.length
              );
              scene.add(raycastMeshGroup);
              raycastMeshes.push(raycastMeshGroup);

              // --- Set Initial Random Matrix for Each Instance in the Group ---
              group.originalIndices.forEach((originalIndex, localIndex) => {
                // Set a random initial position and rotation
                tempPosition.set(
                  (Math.random() - 0.5) * CONFIG.SPREAD_RANGE,
                  (Math.random() - 0.5) * CONFIG.SPREAD_RANGE,
                  (Math.random() - 0.5) * CONFIG.SPREAD_RANGE
                );
                tempQuaternion.setFromEuler(
                  new THREE.Euler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                  )
                );
                tempScale.set(1, 1, 1);
                tempMatrix.compose(tempPosition, tempQuaternion, tempScale);

                // Apply the same initial matrix to both visible and raycast meshes
                visibleMeshGroup.setMatrixAt(localIndex, tempMatrix);
                raycastMeshGroup.setMatrixAt(localIndex, tempMatrix);

                // Link the logical instance data back to the mesh group and its local index
                if (instanceData[originalIndex]) {
                  instanceData[originalIndex].visibleMeshGroup =
                    visibleMeshGroup;
                  instanceData[originalIndex].raycastMeshGroup =
                    raycastMeshGroup;
                  instanceData[originalIndex].localInstanceId = localIndex;
                }
              });

              // Mark matrices for update
              visibleMeshGroup.instanceMatrix.needsUpdate = true;
              raycastMeshGroup.instanceMatrix.needsUpdate = true;
            })
            .catch((error) => {
              // Handle texture load failure for this group
              texturesLoaded++; // Still increment to avoid getting stuck
              updateLoaderProgress(texturesLoaded, totalTexturesToLoad);
              console.error(`Failed to load texture ${imageUrl}:`, error);
              // Consider removing related instances or using a placeholder
            });

          loadPromises.push(loadPromise); // Add the promise to the array
        }

        // Wait for all texture loading attempts to settle (resolve or reject)
        await Promise.allSettled(loadPromises);
        // Final check after all promises are settled
        checkLoadingComplete();
      }

      function updateLoaderProgress(loaded, total) {
        if (loaderElement) {
          const percentage =
            total > 0 ? Math.round((loaded / total) * 100) : 100;
          loaderElement.textContent = `Loading Assets... ${percentage}%`;
        }
      }

      function checkLoadingComplete() {
        // Check if loading is actually complete
        if (
          texturesLoaded >= totalTexturesToLoad &&
          loaderElement &&
          loaderElement.style.display !== "none"
        ) {
          loaderElement.style.display = "none"; // Hide loader
          console.log("Asset loading complete, setup finished.");

          // Manage initial controls visibility based on screen size
          if (isMobile) {
            // Start collapsed on mobile, button shows '☰'
            controlsElement.classList.add("collapsed");
            toggleControlsButton.textContent = "☰";
          } else {
            // Start open on desktop, button shows '✕'
            controlsElement.classList.remove("collapsed");
            toggleControlsButton.textContent = "✕";
          }
        }
      }

      function setupEventListeners() {
        window.addEventListener("resize", onWindowResize);
        // Use pointer events for unified mouse/touch handling
        document.addEventListener(
          "pointermove",
          throttle(onPointerMove, CONFIG.ANIMATION.THROTTLE)
        );
        document.addEventListener("pointerdown", onPointerDown); // Changed from click to pointerdown
        bgColorPicker.addEventListener("input", onBgColorChange);
        visitSiteButton.addEventListener("click", onVisitSiteClick);

        // Layout button listeners
        document.querySelectorAll(".layout-button").forEach((button) => {
          button.addEventListener("click", () => {
            const layout = button.getAttribute("data-layout");
            if (layout !== currentLayout) {
              // Prevent changing to the same layout
              changeLayout(layout);

              // Update active button style
              document.querySelectorAll(".layout-button").forEach((btn) => {
                btn.classList.remove("active");
              });
              button.classList.add("active");
            }
          });
        });

        // Prevent controls intercepting OrbitControls drag on touch devices
        controlsElement.addEventListener("pointerdown", (e) =>
          e.stopPropagation()
        );
        controlsElement.addEventListener("touchstart", (e) =>
          e.stopPropagation()
        ); // Fallback

        // Toggle controls panel visibility
        toggleControlsButton.addEventListener("click", () => {
          controlsElement.classList.toggle("collapsed");
          // Update button text based on state
          toggleControlsButton.textContent = controlsElement.classList.contains(
            "collapsed"
          )
            ? "☰"
            : "✕";
        });
      }

      // Throttle function to limit frequency of event handler calls
      function throttle(func, limit) {
        let inThrottle;
        return function (...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      }

      function onWindowResize() {
        isMobile = window.innerWidth <= 768; // Update mobile status

        // Update camera aspect ratio and projection matrix
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        // Update renderer size and pixel ratio
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // Update controls constraints based on mobile status
        controls.minDistance = isMobile
          ? CONFIG.CAMERA.MOBILE.MIN_DISTANCE
          : CONFIG.CAMERA.DESKTOP.MIN_DISTANCE;
        controls.maxDistance = isMobile
          ? CONFIG.CAMERA.MOBILE.MAX_DISTANCE
          : CONFIG.CAMERA.DESKTOP.MAX_DISTANCE;
        controls.enablePan = !isMobile; // Disable pan on mobile
      }

      function onPointerMove(event) {
        // Calculate normalized device coordinates
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Update pointer world position for Wave Grid
        if (currentLayout === "wavegrid") {
          raycaster.setFromCamera(pointer, camera);
          raycaster.ray.intersectPlane(raycastPlane, pointerWorldPosition); // Find intersection with Z=0 plane
        }

        handleIntersections(false); // Check for hover intersections
      }

      function onPointerDown(event) {
        // 컨트롤 패널 클릭 무시 로직 제거
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
        handleIntersections(true);
      }

      function onBgColorChange(event) {
        const newColor = event.target.value;
        document.body.style.backgroundColor = newColor; // Update body background
        const threeColor = new THREE.Color(newColor);
        if (scene.fog) {
          scene.fog.color.set(threeColor); // Update fog color
        }
        renderer.setClearColor(threeColor); // Update renderer clear color
      }

      function onVisitSiteClick() {
        const url = visitSiteButton.getAttribute("data-url");
        if (url && url !== "https://mayi2d.shop/") {
          // Ensure it's a valid, non-default URL
          window.open(url, "_blank"); // Open in new tab
        } else if (url) {
          // Handle case where URL might be the base shop URL (optional)
          console.log("Visit site clicked for base URL or invalid URL:", url);
          window.open(url, "_blank"); // Or decide not to open
        }
      }

      function handleIntersections(isSelectionAttempt) {
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(raycastMeshes, false);

        let newIntersectedInfo = null;

        if (intersects.length > 0) {
          const intersect = intersects[0];
          if (intersect.instanceId !== undefined) {
            const raycastMeshGroup = intersect.object;
            const localInstanceId = intersect.instanceId;

            const originalIndex = instanceData.findIndex(
              (data) =>
                data &&
                data.raycastMeshGroup === raycastMeshGroup &&
                data.localInstanceId === localInstanceId
            );

            if (originalIndex !== -1) {
              const data = instanceData[originalIndex];
              if (data && data.visibleMeshGroup) {
                const maxDistance = 100;
                if (intersect.distance < maxDistance) {
                  newIntersectedInfo = {
                    originalIndex,
                    meshGroup: data.visibleMeshGroup,
                    localInstanceId,
                    data: data,
                  };
                }
              }
            }
          }
        }

        // --- 호버 상태 변경 처리 ---
        if (
          INTERSECTED_INFO?.originalIndex !== newIntersectedInfo?.originalIndex
        ) {
          // --- 이전 호버 초기화 ---
          if (INTERSECTED_INFO) {
            const oldData = instanceData[INTERSECTED_INFO.originalIndex];
            if (oldData?.visibleMeshGroup && oldData.localInstanceId !== -1) {
              try {
                // 스케일 초기화
                INTERSECTED_INFO.meshGroup.getMatrixAt(
                  INTERSECTED_INFO.localInstanceId,
                  tempMatrix
                );
                tempMatrix.decompose(tempPosition, tempQuaternion, tempScale);
                if (!tempScale.equals(normalScaleVec)) {
                  tempScale.copy(normalScaleVec);
                  tempMatrix.compose(tempPosition, tempQuaternion, tempScale);
                  INTERSECTED_INFO.meshGroup.setMatrixAt(
                    INTERSECTED_INFO.localInstanceId,
                    tempMatrix
                  );
                  INTERSECTED_INFO.meshGroup.instanceMatrix.needsUpdate = true;
                  oldData.raycastMeshGroup?.setMatrixAt(
                    INTERSECTED_INFO.localInstanceId,
                    tempMatrix
                  );
                  oldData.raycastMeshGroup.instanceMatrix.needsUpdate = true;
                }

                // 색상 초기화
                INTERSECTED_INFO.meshGroup.setColorAt(
                  INTERSECTED_INFO.localInstanceId,
                  normalColor
                );
                INTERSECTED_INFO.meshGroup.instanceColor.needsUpdate = true;
              } catch (e) {
                console.error(
                  "Error resetting scale/color:",
                  e,
                  INTERSECTED_INFO
                );
              }
            }
          }

          // --- 새 호버 적용 ---
          if (newIntersectedInfo) {
            const newData = instanceData[newIntersectedInfo.originalIndex];
            if (newData?.visibleMeshGroup && newData.localInstanceId !== -1) {
              try {
                // 호버 스케일 적용
                newIntersectedInfo.meshGroup.getMatrixAt(
                  newIntersectedInfo.localInstanceId,
                  tempMatrix
                );
                tempMatrix.decompose(tempPosition, tempQuaternion, tempScale);
                if (!tempScale.equals(hoverScaleVec)) {
                  tempScale.copy(hoverScaleVec);
                  tempMatrix.compose(tempPosition, tempQuaternion, tempScale);
                  newIntersectedInfo.meshGroup.setMatrixAt(
                    newIntersectedInfo.localInstanceId,
                    tempMatrix
                  );
                  newIntersectedInfo.meshGroup.instanceMatrix.needsUpdate = true;
                  newData.raycastMeshGroup?.setMatrixAt(
                    newIntersectedInfo.localInstanceId,
                    tempMatrix
                  );
                  newData.raycastMeshGroup.instanceMatrix.needsUpdate = true;
                }

                // 호버 색상 적용
                newIntersectedInfo.meshGroup.setColorAt(
                  newIntersectedInfo.localInstanceId,
                  hoverColor
                );
                newIntersectedInfo.meshGroup.instanceColor.needsUpdate = true;
              } catch (e) {
                console.error(
                  "Error applying scale/color:",
                  e,
                  newIntersectedInfo
                );
              }
            }
          }
        }

        // --- 선택 처리 (탭 피드백 추가) ---
        if (isSelectionAttempt && newIntersectedInfo) {
          const data = instanceData[newIntersectedInfo.originalIndex];
          if (data) {
            // 탭 피드백 상태 설정
            if (!data.isTapped) {
              data.isTapped = true;
              data.tapStartTime = clock.getElapsedTime();
            }

            // 선택 패널 업데이트
            selectedItemImage.src = data.imageUrl;
            selectedItemImage.alt = "Selected product";
            visitSiteButton.setAttribute("data-url", data.purchaseUrl);
            selectedItemPanel.style.display = "block";
            visitSiteButton.disabled =
              !data.purchaseUrl || data.purchaseUrl === "https://mayi2d.shop/";

            if (isMobile && controlsElement.classList.contains("collapsed")) {
              controlsElement.classList.remove("collapsed");
              toggleControlsButton.textContent = "✕";
            }
          }
        }

        INTERSECTED_INFO = newIntersectedInfo;
      }

      // Function to apply layout positions instantly without animation
      function applyInstantLayout(positions) {
        if (!positions || positions.length !== instanceData.length) {
          console.error("Cannot apply instant layout: Invalid positions data.");
          return;
        }
        let matrixNeedsUpdate = false;
        instanceData.forEach((data, i) => {
          if (
            data &&
            data.visibleMeshGroup &&
            data.localInstanceId !== -1 &&
            positions[i]
          ) {
            const target = positions[i];
            tempPosition.set(target.x, target.y, target.z);
            // Use target quaternion if available, otherwise keep current rotation
            if (target.quaternion) {
              tempQuaternion.copy(target.quaternion);
            } else {
              // Get current quaternion if not specified by layout
              data.visibleMeshGroup.getMatrixAt(
                data.localInstanceId,
                tempMatrix
              );
              tempMatrix.decompose(
                new THREE.Vector3(),
                tempQuaternion,
                tempScale
              ); // Only need quaternion
            }
            tempScale.set(1, 1, 1); // Reset scale

            tempMatrix.compose(tempPosition, tempQuaternion, tempScale);
            data.visibleMeshGroup.setMatrixAt(data.localInstanceId, tempMatrix);
            data.raycastMeshGroup.setMatrixAt(data.localInstanceId, tempMatrix);
            matrixNeedsUpdate = true;

            // Store layout-specific data if needed (e.g., baseZ for wavegrid)
            if (target.baseZ !== undefined) data.targetZ = target.baseZ;
            if (target.layerIndex !== undefined)
              data.layerIndex = target.layerIndex;
          }
        });

        if (matrixNeedsUpdate) {
          instancedMeshes.forEach((mesh) => {
            mesh.instanceMatrix.needsUpdate = true;
          });
          raycastMeshes.forEach((mesh) => {
            mesh.instanceMatrix.needsUpdate = true;
          });
          console.log(`Applied initial layout: ${currentLayout}`);
        }
      }

      function changeLayout(layoutType) {
        if (
          !instanceData.length ||
          layoutType === currentLayout ||
          isTransitioning
        )
          return;

        console.log(`Changing layout to: ${layoutType}`);
        currentLayout = layoutType;
        isTransitioning = true;
        transitionStartTime = clock.getElapsedTime();

        // Store starting positions and rotations
        startPositions = instanceData.map((data) => {
          if (data && data.visibleMeshGroup && data.localInstanceId !== -1) {
            data.visibleMeshGroup.getMatrixAt(data.localInstanceId, tempMatrix);
            tempMatrix.decompose(tempPosition, tempQuaternion, tempScale);
            // Create a new object for the start state
            return {
              x: tempPosition.x,
              y: tempPosition.y,
              z: tempPosition.z,
              quaternion: tempQuaternion.clone(), // Clone the quaternion
            };
          }
          // Return a default state if data is invalid
          return { x: 0, y: 0, z: 0, quaternion: new THREE.Quaternion() };
        });

        // Calculate target positions and rotations for the new layout
        targetPositions = calculateTargetPositions(layoutType);
      }

      function calculateTargetPositions(layoutType) {
        const totalInstances = instanceData.length;
        const positions = []; // Array to store { x, y, z, quaternion, [optional data] }

        switch (layoutType) {
          case "sphere": {
            // Added block scope
            const { RADIUS, SPREAD, ORBIT_SPEED, SELF_ROTATION_SPEED } =
              CONFIG.LAYOUT.SPHERE;
            const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // For Fibonacci sphere distribution

            for (let i = 0; i < totalInstances; i++) {
              const y = 1 - (i / (totalInstances - 1)) * 2; // -1 to 1
              const radiusAtY = Math.sqrt(1 - y * y);
              const theta = goldenAngle * i;
              const x = Math.cos(theta) * radiusAtY;
              const z = Math.sin(theta) * radiusAtY;

              const finalRadius =
                RADIUS * (1 + (Math.random() - 0.5) * SPREAD * 2);
              const pos = new THREE.Vector3(
                x * finalRadius,
                y * finalRadius,
                z * finalRadius
              );

              // Calculate orientation to face outwards
              tempObject.position.copy(pos);
              tempObject.lookAt(0, 0, 0); // Look at center
              tempObject.rotation.y += Math.PI; // Turn around to face out

              positions.push({
                x: pos.x,
                y: pos.y,
                z: pos.z,
                quaternion: tempObject.quaternion.clone(),
              });
            }
            break;
          } // End sphere case

          case "grid": // Fall through to wavegrid for base calculation
          case "wavegrid": {
            // Added block scope
            const { COLUMNS, SPACING, POSITION_JITTER, ROTATION_JITTER } =
              CONFIG.LAYOUT.GRID;
            const rows = Math.ceil(totalInstances / COLUMNS);

            for (let i = 0; i < totalInstances; i++) {
              const row = Math.floor(i / COLUMNS);
              const col = i % COLUMNS;

              const baseX = (col - (COLUMNS - 1) / 2) * SPACING;
              const baseY = (row - (rows - 1) / 2) * SPACING;
              const baseZ = 0; // Base Z for grid

              const finalX = baseX + (Math.random() - 0.5) * POSITION_JITTER;
              const finalY = baseY + (Math.random() - 0.5) * POSITION_JITTER;
              const finalZ =
                baseZ + (Math.random() - 0.5) * POSITION_JITTER * 0.5; // Slight Z jitter

              const randomZRotation = (Math.random() - 0.5) * ROTATION_JITTER;
              const targetQuaternion = new THREE.Quaternion().setFromEuler(
                new THREE.Euler(0, 0, randomZRotation) // Face camera with Z jitter
              );

              positions.push({
                x: finalX,
                y: finalY,
                z: finalZ, // This is the initial position, targetZ will be baseZ
                quaternion: targetQuaternion,
                baseZ: baseZ, // Store the target base Z specifically for wavegrid animation
              });
            }
            break;
          } // End grid/wavegrid case

          case "spiral": {
            // Added block scope
            const {
              RADIUS,
              TURNS,
              SPREAD,
              HEIGHT_FACTOR,
              WAVE_FREQ,
              WAVE_AMP,
            } = CONFIG.LAYOUT.SPIRAL;

            for (let i = 0; i < totalInstances; i++) {
              const t = i / (totalInstances - 1); // 0 to 1
              const angle = t * TURNS * Math.PI * 2;
              const currentRadius =
                RADIUS * (1 + (Math.random() - 0.5) * SPREAD * 2);
              const x = currentRadius * Math.cos(angle);
              const y = currentRadius * Math.sin(angle);
              // Z position with wave and height scaling
              const z =
                Math.sin(t * Math.PI * WAVE_FREQ) * WAVE_AMP * HEIGHT_FACTOR;

              const pos = new THREE.Vector3(x, y, z);

              // Orientation: Look towards the Z-axis at the same height
              const lookAtPoint = new THREE.Vector3(0, 0, z);
              tempObject.position.copy(pos);
              tempObject.lookAt(lookAtPoint);

              positions.push({
                x: pos.x,
                y: pos.y,
                z: pos.z,
                quaternion: tempObject.quaternion.clone(),
              });
            }
            break;
          } // End spiral case

          case "flow": {
            // Added block scope
            // Flow layout doesn't have fixed target positions.
            // Initialize randomly like the 'random' layout.
            // The actual movement happens entirely in the animate() function.
            for (let i = 0; i < totalInstances; i++) {
              positions.push({
                x: (Math.random() - 0.5) * CONFIG.SPREAD_RANGE,
                y: (Math.random() - 0.5) * CONFIG.SPREAD_RANGE,
                z: (Math.random() - 0.5) * CONFIG.SPREAD_RANGE,
                // No specific quaternion target, let it animate freely
                quaternion: new THREE.Quaternion().setFromEuler(
                  new THREE.Euler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                  )
                ),
              });
              // Reset velocities when switching to flow
              if (instanceData[i]) {
                instanceData[i].velocity.set(0, 0, 0);
                instanceData[i].angularVelocity.set(0, 0, 0);
              }
            }
            break;
          } // End flow case

          case "panorama": {
            // Added block scope
            const {
              NUM_LAYERS,
              LAYER_DEPTH,
              RADIUS,
              ITEM_SPACING_X,
              ITEM_SPACING_Y,
              ARRANGEMENT,
              PARALLAX_FACTOR,
              LAYER_OSCILLATION,
            } = CONFIG.LAYOUT.PANORAMA;
            const instancesPerLayer = Math.ceil(totalInstances / NUM_LAYERS);
            const centerLayerOffset = ((NUM_LAYERS - 1) * LAYER_DEPTH) / 2; // Center Z = 0

            for (let i = 0; i < totalInstances; i++) {
              const layerIndex = Math.floor(i / instancesPerLayer);
              const indexInLayer = i % instancesPerLayer;
              const layerZ = layerIndex * LAYER_DEPTH - centerLayerOffset;

              let x,
                y,
                z = layerZ;
              let targetQuaternion = new THREE.Quaternion();

              if (ARRANGEMENT === "cylindrical") {
                const angle = (indexInLayer / instancesPerLayer) * Math.PI * 2;
                // Adjust radius slightly per layer (optional)
                const layerRadius = RADIUS * (1 - layerIndex * 0.05);
                x = Math.cos(angle) * layerRadius;
                y = Math.sin(angle) * layerRadius;

                // Orient to face the center (Y-axis)
                tempObject.position.set(x, y, z);
                tempObject.lookAt(0, 0, z); // Look towards center axis at same Z
                targetQuaternion.copy(tempObject.quaternion);
              } else {
                // Planar arrangement
                const itemsPerRow = Math.floor((RADIUS * 2) / ITEM_SPACING_X); // Estimate items per row
                const col = indexInLayer % itemsPerRow;
                const row = Math.floor(indexInLayer / itemsPerRow);
                x = (col - (itemsPerRow - 1) / 2) * ITEM_SPACING_X;
                y =
                  (row - Math.floor(instancesPerLayer / itemsPerRow / 2)) *
                  ITEM_SPACING_Y; // Center vertically

                // Orient to face the camera (simple Z rotation is enough)
                targetQuaternion.setFromEuler(new THREE.Euler(0, 0, 0));
              }

              positions.push({
                x: x + (Math.random() - 0.5) * 0.5, // Add slight jitter
                y: y + (Math.random() - 0.5) * 0.5,
                z: z,
                quaternion: targetQuaternion,
                layerIndex: layerIndex, // Store layer index for parallax/animation
              });
            }
            break;
          } // End panorama case

          case "random":
          default: {
            // Added block scope
            for (let i = 0; i < totalInstances; i++) {
              positions.push({
                x: (Math.random() - 0.5) * CONFIG.SPREAD_RANGE,
                y: (Math.random() - 0.5) * CONFIG.SPREAD_RANGE,
                z: (Math.random() - 0.5) * CONFIG.SPREAD_RANGE,
                // Random initial orientation
                quaternion: new THREE.Quaternion().setFromEuler(
                  new THREE.Euler(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                  )
                ),
              });
            }
            break;
          } // End random/default case
        } // End switch

        return positions;
      }

      // --- Main Animation Loop ---
      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const elapsedTime = clock.getElapsedTime();

        let matrixNeedsUpdate = false;

        // --- 레이아웃 전환 애니메이션 ---
        if (isTransitioning) {
          const transitionProgress = Math.min(
            (elapsedTime - transitionStartTime) /
              CONFIG.ANIMATION.TRANSITION_DURATION,
            1.0
          );
          const easeProgress = easeInOutCubic(transitionProgress); // Apply easing

          instanceData.forEach((data, i) => {
            if (
              data &&
              data.visibleMeshGroup && // Check if mesh group exists
              data.localInstanceId !== -1 && // Check for valid local index
              startPositions[i] && // Check if start position exists
              targetPositions[i] // Check if target position exists
            ) {
              try {
                // Get current matrix (needed for scale preservation if any)
                // data.visibleMeshGroup.getMatrixAt(data.localInstanceId, tempMatrix);
                // tempMatrix.decompose(tempPosition, tempQuaternion, tempScale);
                // NOTE: For simplicity during transition, we'll lerp position and slerp quaternion directly
                // and apply a scale of 1, discarding any temporary hover scale.

                const start = startPositions[i];
                const target = targetPositions[i];

                // Interpolate Position (Lerp)
                tempPosition.lerpVectors(
                  new THREE.Vector3(start.x, start.y, start.z),
                  new THREE.Vector3(target.x, target.y, target.z),
                  easeProgress
                );

                // Interpolate Rotation (Slerp)
                // Ensure both start and target quaternions are valid
                const startQuat = start.quaternion || new THREE.Quaternion();
                const targetQuat = target.quaternion || new THREE.Quaternion(); // Use identity if target has no rotation
                tempQuaternion.slerpQuaternions(
                  startQuat,
                  targetQuat,
                  easeProgress
                );

                // Apply Normal Scale during transition
                tempScale.set(1, 1, 1);

                // Compose and set the matrix
                tempMatrix.compose(tempPosition, tempQuaternion, tempScale);
                data.visibleMeshGroup.setMatrixAt(
                  data.localInstanceId,
                  tempMatrix
                );
                // Update raycast mesh as well
                data.raycastMeshGroup?.setMatrixAt(
                  data.localInstanceId,
                  tempMatrix
                );
                matrixNeedsUpdate = true;

                // Store layout-specific data at the start of transition if needed for the target layout
                if (transitionProgress < 0.1) {
                  // Only at the very beginning
                  if (target.baseZ !== undefined) data.targetZ = target.baseZ;
                  if (target.layerIndex !== undefined)
                    data.layerIndex = target.layerIndex;
                  // Reset flow velocity at start of transition away from flow
                  if (currentLayout !== "flow") {
                    data.velocity?.set(0, 0, 0);
                    data.angularVelocity?.set(0, 0, 0);
                  }
                  // Reset wave offset
                  data.currentZOffset = 0;
                }
              } catch (error) {
                console.error(
                  `Error during transition for instance ${i}:`,
                  error,
                  data,
                  start,
                  target
                );
              }
            }
          }); // End instance loop

          // --- Transition Completion ---
          if (transitionProgress >= 1.0) {
            isTransitioning = false;
            console.log("Layout transition complete.");
            // Optional: Snap to final target position/rotation precisely
            instanceData.forEach((data, i) => {
              if (
                data &&
                data.visibleMeshGroup &&
                data.localInstanceId !== -1 &&
                targetPositions[i]
              ) {
                const target = targetPositions[i];
                tempPosition.set(target.x, target.y, target.z);
                tempQuaternion.copy(
                  target.quaternion || new THREE.Quaternion()
                ); // Use target or identity quat
                tempScale.set(1, 1, 1); // Ensure normal scale
                tempMatrix.compose(tempPosition, tempQuaternion, tempScale);
                data.visibleMeshGroup.setMatrixAt(
                  data.localInstanceId,
                  tempMatrix
                );
                data.raycastMeshGroup?.setMatrixAt(
                  data.localInstanceId,
                  tempMatrix
                );

                // Store layout-specific data from target
                if (target.baseZ !== undefined) data.targetZ = target.baseZ;
                if (target.layerIndex !== undefined)
                  data.layerIndex = target.layerIndex;
                // Ensure flow velocity is zero if not in flow layout
                if (currentLayout !== "flow") {
                  data.velocity?.set(0, 0, 0);
                  data.angularVelocity?.set(0, 0, 0);
                }
                // Reset wave offset
                data.currentZOffset = 0;
              }
            });
            matrixNeedsUpdate = true; // Ensure final snap is updated
          }
        } else {
          // --- 레이아웃별 유휴 애니메이션 ---
          instanceData.forEach((data, i) => {
            if (
              data &&
              data.visibleMeshGroup &&
              data.raycastMeshGroup &&
              data.localInstanceId !== -1
            ) {
              try {
                // 현재 매트릭스 상태 가져오기
                data.visibleMeshGroup.getMatrixAt(
                  data.localInstanceId,
                  tempMatrix
                );
                tempMatrix.decompose(tempPosition, tempQuaternion, tempScale);

                const isHovered =
                  INTERSECTED_INFO && INTERSECTED_INFO.originalIndex === i;

                // 기본 스케일 결정 (호버 상태 고려)
                let currentBaseScaleVec = isHovered
                  ? hoverScaleVec
                  : normalScaleVec;

                // ******** 탭 피드백 효과 적용 (추가된 부분) ********
                let finalScaleVec = currentBaseScaleVec.clone();

                if (data.isTapped) {
                  const tapDuration = 0.2; // 탭 효과 지속 시간 (초)
                  const tapMaxScaleFactor = 1.15; // 최대 스케일 배율
                  const timeSinceTap = elapsedTime - data.tapStartTime;

                  if (timeSinceTap < tapDuration) {
                    const progress = timeSinceTap / tapDuration;
                    const tapScalePulse =
                      1 +
                      (tapMaxScaleFactor - 1) * Math.sin(progress * Math.PI);
                    finalScaleVec.multiplyScalar(tapScalePulse);
                  } else {
                    data.isTapped = false;
                  }
                  matrixNeedsUpdate = true;
                }
                // **************************************************

                // --- 레이아웃별 위치/회전 애니메이션 ---
                switch (currentLayout) {
                  case "sphere": {
                    const ORBIT_SPEED = CONFIG.LAYOUT.SPHERE.ORBIT_SPEED;
                    const SELF_ROTATION_SPEED =
                      CONFIG.LAYOUT.SPHERE.SELF_ROTATION_SPEED;

                    const orbitQuat = new THREE.Quaternion().setFromAxisAngle(
                      new THREE.Vector3(0, 1, 0),
                      ORBIT_SPEED * delta
                    );
                    tempPosition.applyQuaternion(orbitQuat);

                    tempObject.position.copy(tempPosition);
                    tempObject.lookAt(0, 0, 0);
                    tempObject.rotation.y += Math.PI;

                    const selfRotateQuat =
                      new THREE.Quaternion().setFromAxisAngle(
                        new THREE.Vector3(0, 1, 0),
                        SELF_ROTATION_SPEED * delta
                      );
                    tempQuaternion
                      .copy(tempObject.quaternion)
                      .premultiply(selfRotateQuat);
                    break;
                  }
                  case "grid": {
                    // Mostly static, maybe a very slow idle rotation?
                    const { GRID_IDLE_ROT_SPEED } = CONFIG.ANIMATION;
                    if (GRID_IDLE_ROT_SPEED > 0) {
                      const idleRotateQuat =
                        new THREE.Quaternion().setFromAxisAngle(
                          new THREE.Vector3(0, 0, 1),
                          GRID_IDLE_ROT_SPEED * delta * (i % 2 === 0 ? 1 : -1)
                        ); // Vary direction
                      tempQuaternion.premultiply(idleRotateQuat);
                    }
                    break;
                  }
                  case "wavegrid": {
                    const {
                      EFFECT_RADIUS,
                      MAX_DISPLACEMENT,
                      WAVE_SPEED,
                      DAMPING,
                    } = CONFIG.LAYOUT.WAVEGRID;
                    const baseZ = data.targetZ !== undefined ? data.targetZ : 0; // Use stored base Z

                    // Calculate distance from pointer in XZ plane (or use 3D distance)
                    const dist = tempPosition.distanceTo(pointerWorldPosition);
                    let waveOffset = 0;

                    if (dist < EFFECT_RADIUS) {
                      // Calculate wave displacement based on distance and time
                      const distanceFactor = 1.0 - dist / EFFECT_RADIUS; // 1 at center, 0 at edge
                      // Use Math.pow for sharper falloff, or keep linear
                      const waveFactor = Math.pow(distanceFactor, 2); // Sharper falloff
                      waveOffset =
                        waveFactor *
                        MAX_DISPLACEMENT *
                        Math.sin(elapsedTime * WAVE_SPEED - dist * 0.5); // Sine wave based on time and distance
                    }

                    // Smoothly interpolate the current offset towards the target offset
                    data.currentZOffset = THREE.MathUtils.lerp(
                      data.currentZOffset,
                      waveOffset,
                      1 - DAMPING
                    );

                    tempPosition.z = baseZ + data.currentZOffset; // Apply smoothed offset

                    // Optional: Add slight rotation based on wave?
                    // const rotFactor = data.currentZOffset * 0.1;
                    // const waveRotQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(rotFactor, 0, 0));
                    // tempQuaternion.premultiply(waveRotQuat);

                    break;
                  }
                  case "spiral": {
                    const { SPIRAL_STRUCT_ROT_SPEED, SPIRAL_SELF_ROT_SPEED } =
                      CONFIG.ANIMATION;
                    // Rotate the whole structure around Z axis
                    if (SPIRAL_STRUCT_ROT_SPEED > 0) {
                      const structRotateQuat =
                        new THREE.Quaternion().setFromAxisAngle(
                          new THREE.Vector3(0, 0, 1),
                          SPIRAL_STRUCT_ROT_SPEED * delta
                        );
                      tempPosition.applyQuaternion(structRotateQuat);
                    }

                    // Re-orient to look at Z-axis after structure rotation
                    const lookAtPoint = new THREE.Vector3(0, 0, tempPosition.z);
                    tempObject.position.copy(tempPosition);
                    tempObject.lookAt(lookAtPoint);
                    const baseQuaternion = tempObject.quaternion.clone();

                    // Apply self-rotation (tumbling around local Y)
                    const selfRotateQuat =
                      new THREE.Quaternion().setFromAxisAngle(
                        new THREE.Vector3(0, 1, 0),
                        SPIRAL_SELF_ROT_SPEED * delta
                      );
                    tempQuaternion
                      .copy(baseQuaternion)
                      .premultiply(selfRotateQuat); // Apply base orientation, then self-rotation

                    break;
                  }
                  case "flow": {
                    const {
                      NOISE_SCALE,
                      SPEED,
                      FORCE,
                      ROTATION_DAMPING,
                      MAX_SPEED,
                    } = CONFIG.LAYOUT.FLOW;
                    const noiseTime = elapsedTime * SPEED;

                    // --- Calculate Flow Field Force using Noise ---
                    // Placeholder: Use simplex3 noise function here
                    // Ensure you have imported/defined 'noise.simplex3'
                    const noiseValX =
                      noise.simplex3(
                        tempPosition.x * NOISE_SCALE,
                        tempPosition.y * NOISE_SCALE,
                        noiseTime
                      ) || 0;
                    const noiseValY =
                      noise.simplex3(
                        tempPosition.y * NOISE_SCALE,
                        tempPosition.z * NOISE_SCALE,
                        noiseTime
                      ) || 0;
                    const noiseValZ =
                      noise.simplex3(
                        tempPosition.z * NOISE_SCALE,
                        tempPosition.x * NOISE_SCALE,
                        noiseTime
                      ) || 0;

                    // Create force vector from noise, normalize, and scale
                    const forceVector = new THREE.Vector3(
                      noiseValX,
                      noiseValY,
                      noiseValZ
                    );
                    forceVector.normalize().multiplyScalar(FORCE * delta); // Apply force over time

                    // --- Update Velocity & Position ---
                    data.velocity.add(forceVector);
                    // Clamp velocity to max speed
                    if (data.velocity.length() > MAX_SPEED) {
                      data.velocity.normalize().multiplyScalar(MAX_SPEED);
                    }
                    tempPosition.addScaledVector(data.velocity, delta); // Update position based on velocity

                    // --- Calculate Rotation based on Velocity Direction ---
                    if (data.velocity.lengthSq() > 0.001) {
                      // Only rotate if moving significantly
                      // Create a target quaternion that aligns Z-axis with velocity
                      tempObject.position.copy(tempPosition);
                      tempObject.lookAt(
                        tempPosition.clone().add(data.velocity)
                      ); // Look in direction of movement
                      const targetFlowQuat = tempObject.quaternion;

                      // Slerp towards the target rotation for smoother turning
                      tempQuaternion.slerp(targetFlowQuat, 0.1); // Adjust slerp factor for responsiveness
                    }

                    // --- Apply Damping to Velocity (optional drag) ---
                    // data.velocity.multiplyScalar(0.99); // Slow down slightly over time

                    // --- Boundary Check (optional: wrap around or bounce) ---
                    const boundary = CONFIG.SPREAD_RANGE * 0.8;
                    if (tempPosition.length() > boundary) {
                      // Option 1: Wrap around
                      // tempPosition.multiplyScalar(-1 * (boundary - 0.1) / boundary);
                      // Option 2: Simple push back towards center
                      data.velocity.addScaledVector(
                        tempPosition,
                        -0.01 * delta
                      );
                    }

                    break;
                  }
                  case "panorama": {
                    const {
                      LAYER_ROTATION_SPEED,
                      PARALLAX_FACTOR,
                      LAYER_OSCILLATION,
                    } = CONFIG.LAYOUT.PANORAMA;

                    // --- 레이어별 진동 효과 ---
                    const layerOscillation =
                      Math.sin(elapsedTime * LAYER_OSCILLATION.FREQUENCY) *
                      LAYER_OSCILLATION.AMPLITUDE *
                      (data.layerIndex - 2); // 중앙 레이어 기준으로 진동 (5개 레이어에 맞게 조정)

                    // --- 전체 파노라마 회전 ---
                    if (LAYER_ROTATION_SPEED > 0) {
                      const panoRotateQuat =
                        new THREE.Quaternion().setFromAxisAngle(
                          new THREE.Vector3(0, 1, 0),
                          LAYER_ROTATION_SPEED * delta
                        );
                      tempPosition.applyQuaternion(panoRotateQuat);
                      tempQuaternion.premultiply(panoRotateQuat);
                    }

                    // --- 패럴랙스 효과 ---
                    if (PARALLAX_FACTOR > 0 && controls) {
                      const cameraAngleY = controls.getAzimuthalAngle();
                      const numLayers = CONFIG.LAYOUT.PANORAMA.NUM_LAYERS;
                      const centerLayerIndex = (numLayers - 1) / 2;
                      const layerOffset = data.layerIndex - centerLayerIndex;

                      // 더 강한 패럴랙스 효과
                      const parallaxOffset =
                        -cameraAngleY * PARALLAX_FACTOR * layerOffset * 4;
                      tempPosition.x += parallaxOffset * delta;

                      // 레이어별 Z축 진동 추가
                      tempPosition.z += layerOscillation * delta;
                    }

                    // --- 아이템 방향 조정 ---
                    tempObject.position.copy(tempPosition);
                    tempObject.lookAt(0, 0, tempPosition.z);
                    tempQuaternion.copy(tempObject.quaternion);

                    // --- 레이어별 회전 속도 차이 ---
                    const layerSpeedFactor = 1 + (data.layerIndex - 2) * 0.15; // 속도 차이를 더 크게 조정
                    const layerRotateQuat =
                      new THREE.Quaternion().setFromAxisAngle(
                        new THREE.Vector3(0, 1, 0),
                        LAYER_ROTATION_SPEED * delta * layerSpeedFactor
                      );
                    tempQuaternion.premultiply(layerRotateQuat);

                    break;
                  }
                  case "random":
                  default: {
                    // Existing random float and rotation animation
                    const { FLOAT_AMPLITUDE, FLOAT_SPEED } =
                      CONFIG.LAYOUT.RANDOM;
                    const floatOffset =
                      Math.sin(elapsedTime * FLOAT_SPEED + i * 0.5) *
                      FLOAT_AMPLITUDE; // Unique offset per item
                    tempPosition.y += floatOffset * delta * 5; // Apply float smoothly

                    // Apply random rotation based on initial random speed
                    // Note: InstanceData needs rotationSpeed property for this
                    // if (data.rotationSpeed) { // Check if rotationSpeed exists
                    //     const deltaQuatX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), data.rotationSpeed.x * delta);
                    //     const deltaQuatY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), data.rotationSpeed.y * delta);
                    //     const deltaQuatZ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), data.rotationSpeed.z * delta);
                    //     tempQuaternion.premultiply(deltaQuatX).premultiply(deltaQuatY).premultiply(deltaQuatZ);
                    // }
                    break;
                  }
                } // End layout switch

                // --- Compose Final Matrix & Apply ---
                // The hover scale was applied earlier
                tempMatrix.compose(tempPosition, tempQuaternion, finalScaleVec);
                data.visibleMeshGroup.setMatrixAt(
                  data.localInstanceId,
                  tempMatrix
                );
                data.raycastMeshGroup.setMatrixAt(
                  data.localInstanceId,
                  tempMatrix
                ); // Keep raycast mesh synced
                matrixNeedsUpdate = true; // Mark for update
              } catch (error) {
                console.error(
                  `Error animating instance ${i} in layout ${currentLayout}:`,
                  error
                );
                // Optionally disable animation for this instance if errors persist
              }
            }
          }); // End instance loop (for idle animations)
        } // End 'isTransitioning' block

        // --- 글로벌 업데이트 ---
        if (matrixNeedsUpdate) {
          instancedMeshes.forEach((mesh) => {
            if (mesh.instanceMatrix) mesh.instanceMatrix.needsUpdate = true;
            // Also update color buffer if hover effects changed it
            if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
          });
          raycastMeshes.forEach((mesh) => {
            if (mesh.instanceMatrix) mesh.instanceMatrix.needsUpdate = true;
          });
        }

        // 파티클, 조명, 컨트롤 업데이트
        if (particleSystem) {
          particleSystem.rotation.y += delta * 0.005;
          particleSystem.rotation.x += delta * 0.002;
        }

        pointLights.forEach((light) => {
          light.userData.angle += light.userData.speed * delta * 0.5;
          const radiusFactor =
            1 +
            Math.sin(elapsedTime * 0.15 + light.userData.angle * 0.25) * 0.05;
          const currentRadius = light.userData.radius * radiusFactor;
          const x = Math.cos(light.userData.angle) * currentRadius;
          const y =
            Math.sin(elapsedTime * light.userData.speed * 0.25) * 3 +
            light.userData.yOffset;
          const z = Math.sin(light.userData.angle) * currentRadius;
          light.position.set(x, y, z);
        });

        backgroundLight.intensity = 2.5 + Math.sin(elapsedTime * 0.3) * 0.8;
        backLight.intensity = 1.5 + Math.sin(elapsedTime * 0.2) * 0.5;

        // Update OrbitControls (Handles damping)
        if (controls) controls.update(); // Pass delta if needed by specific controls features

        // Render the Scene
        if (renderer && scene && camera) renderer.render(scene, camera);
      } // --- End animate() ---

      // --- Helper Functions ---
      function easeInOutCubic(x) {
        // Cubic easing function for smooth transitions
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
      }

      async function loadTexture(loader, url) {
        if (!url)
          return Promise.reject(new Error("Texture URL is empty or invalid"));
        // Return cached texture if available
        if (textureCache.has(url)) {
          const cached = textureCache.get(url);
          if (cached instanceof Promise) return cached; // Return promise if still loading
          if (cached instanceof THREE.Texture) return Promise.resolve(cached); // Return texture if loaded
        }

        // Load texture and cache the promise
        const promise = new Promise((resolve, reject) => {
          loader.load(
            url,
            (texture) => {
              texture.colorSpace = THREE.SRGBColorSpace; // Correct color space for web images
              texture.minFilter = THREE.LinearFilter; // Good quality filtering
              texture.magFilter = THREE.LinearFilter;
              texture.needsUpdate = true; // Ensure texture updates GPU
              textureCache.set(url, texture); // Cache the loaded texture
              resolve(texture);
            },
            undefined, // onProgress callback (optional)
            (errorEvent) => {
              console.error(`Error loading texture: ${url}`, errorEvent);
              textureCache.delete(url); // Remove failed entry from cache
              reject(new Error(`Failed to load texture ${url}`));
            }
          );
        });
        textureCache.set(url, promise); // Cache the promise itself initially
        return promise;
      }

      function showError(message) {
        // Display error message prominently
        if (loaderElement) {
          loaderElement.textContent = message;
          loaderElement.style.color = "red";
          loaderElement.style.display = "block";
        } else {
          // Fallback if loader element isn't found
          const errorDiv = document.createElement("div");
          errorDiv.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(200, 0, 0, 0.8); color: white; padding: 20px;
            border-radius: 5px; z-index: 1000; text-align: center;
          `;
          errorDiv.textContent = message;
          document.body.appendChild(errorDiv);
        }
      }
    </script>
  </body>
</html>
